<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Refactoring Proposal</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="http://dev.eclipse.org/default_style.css"
	type="text/css" />
</head>
<body style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0)">

<table border="0" cellspacing="5" cellpadding="2" width="100%">
	<colgroup>
		<col valign="top" width="2%" />
		<col valign="top" width="98%" />
	</colgroup>
	<tbody>
		<tr>
			<td align="center" valign="top" colspan="2" bgcolor="#0080c0"
				width="100%"><b><font face="Arial,Helvetica" color="#ffffff"
				size="5">Request for Comments</font></b></td>
		</tr>
	</tbody>
</table>

<h2 align="center">Expression Evaluation for plugin.xml files</h2>


This proposal outlines a unified solution how to evaluate expressions in
plugin.xml files. The effort and the document is a spin-off of the
<a href="../refactoring/participants.html">refactoring participant</a>
work for which the presented solution got implemented. Feedback is
strongly encouraged and may be provided on the ?? mailing list.


<p>Last modified: October 24, 2003</p>
<h3>Motivation</h3>
<p>One of the JDT plan items is to provide means for other plug-ins to
participate in operations like refactoring (e.g. rename, move, delete,
...), and searching (e.g search for reference to a method) or to
contribute additional functionality like new quick fixes and quick
assists. To avoid unnecessary plug-in activation these contributions need
a mechanism to describe their availability. This is in particular important
if an operation will load additional plug-ins. Consider the following
scenario: a JSP plug-in provides a rename method participant to adapt
JSP files during a method rename. Loading this participant is only
necessary if a accessible method (e.g not private, ...) gets renamed and
if the user does JSP development at all. Since contributions are
declared via XML the provider of such a rename participants needs some
sort of expression language to define the participants availability. Up
to now each extension point provider somehow invented its own expression
language which has the following disadvantages:</p>
<ul>
	<li>code duplication</li>
	<li>different syntax</li>
	<li>different functionality</li>
</ul>
<p>To avoid this proliferation one homogeneous expression evaluation
mechanism is proposed.</p>
<h3><a name="property_evaluation">Existing Mechanisms</a></h3>
<p>Why implementing a new mechanism and not simply promote one of the
existing ones? The mechanism provided by Platform/UI to control the
enablement state of action contributions looks very similar to the one
proposed in this document. I implemented a new mechanism instead of
(re)using the existing mechanism due to the following reasons:</p>
<ul>
	<li>refactoring, search, ... will become core functionality in 3.0.
	Therefore expression evaluation must be provided by a non UI plug-in.</li>

	<li>Platform/UI evaluation mechanism is based on the adaptable
	mechanism using IActionFilter as the adaptable interface. The adaptable
	mechanism only support one adapter of the same &quot;class&quot; per
	type. For example, two different plug-ins can't contribute different
	IActionFilters for ICompilationUnit.</li>
	<li>IActionFilter interprets the case that a property can't be
	evaluated because the plug-in providing the filter isn't loaded yet as
	true. This can result in unneeded plug-in activation. The new
	implementation uses the three values: FALSE, TRUE, NOT_LOADED.</li>
	<li>Action enablement in the UI supports the notion of
	&quot;adaptable&quot;. If requested, the workbench adapts the element
	to be checked to <code>IContributorResourceAdapter</code>. In an open
	architecture the class to which the element is to be adapted must be
	configurable. Consider a call hierarchy view which model is a wrapper
	around Java elements. To enable Java refactoring actions on call
	hierarchy nodes the refactoring should check if the element can be
	adapted to IJavaElement.</li>
</ul>
<h3>Proposed Implementation</h3>
<p>The proposed implementation is split into two different parts. Part
one provides classes to &quot;convert&quot; XML elements (instance of
IConfigurationElement) into expression objects. Since the set of
expression can't be predicted this mechanism must be open. Additionally
this part defines the logic for the three expression results FALSE,
TRUE, NOT_LOADED. Part two provides a standard expression language
similar to the one provided by Platform/UI avoiding the shortcomings
caused by the used of IActionFilter.</p>
<p>The outlined implementation currently resides in JDT/UI package
org.eclipse.jdt.internal.corext.refactoring.participants.xml. So please
ignore strange package names or extension point ids. As always you understand ideas better after you have written them
down. Therefore the proposal contains some concepts not yet implemented
or implemented in a different way.</p>
<h4>Converting XML elements into expressions</h4>
<p>As already explained above this component is responsible to convert XML
elements into expressions. The component is formed by the following types:</p>
<ul>
	<li><i>TestResult</i>: this class encapsulates the three result values
	FALSE, TRUE and NOT_LOADED and defines the logic for the the standard
	operators and, or and not.</li>
	<li><i>Expression</i>: the abstract base class of all expressions,
	defining a method <code>evaluate</code> which returns an instanceof of
	TestResult.</li>
	<li><i>IElementHandler</i>: an interface defining a method to convert a
	set of XML elements into a corresponding expression.</li>
	<li><i>ExpressionCreator</i>: concrete class that is instantiated with
	a list of element handlers. The expression creator is responsible to
	convert an IConfigurationElement into an expression.</li>
</ul>
<p><i>TBD: give an example of an IElementHandler implementation and how
an configuration element is converted. Note that this opens the set of expressions. So if we would like to add beanshell support in the future this can be done by a new expression element &lt;beanshell&gt;statements....&lt;/beanshell&gt;.</i></p>
<p>The approach of converting &quot;existing&quot; configuration
elements into expressions has the disadvantage that both structures
have to be managed and that both consume memory. Following several
proposals to handle this disadvantage:</p>
<ol>
	<li type="1">we live with this situation.</li>
	<li type="1">after a tree of configuration elements has been converted
	into the corresponding expression the configuration element gets
	replaced with one keeping only a reference to the expression (not to
	the config element children). The problem with this approach is that
	the config tree structure doesn't fully reflect the content of the
	plugin.xml file anymore. But since extension points are typically only
	interpreted by the plugin that defines the extension point this
	shouldn't cause any harm. Additionally the conversion doesn't take
	place automatically so it is fully backwards compatible.</li>
	<li type="1">the plug-in registry converts XML elements representing
	expression into a corresponding expression tree while reading the
	plug-in XML file. This ensures minimal memory consumption and a nice
	API for clients (they could directly call a method getExpression()).
	But to avoid unnecessary plug-in loading during registry creation the
	set of expressions must be fixed so that they are known to the
	component creating the registry.</li>
	<li type="1">the configuration element itself (or a special subclass)
	offers a method to convert the element and its children into a
	corresponding expression. This can be done by either passing an
	expression creator explicitly or by managing expression creators and/or
	element handlers via extension points. Pluggability raise the issue what to do if the
	plug-in providing a special handler isn't loaded yet. This would result in the fact that the whole expression can't be created or that we have to create some sort of proxies which fail during evaluation.</li>
</ol>
<p>I am not sure, which solution to propose. I &quot;currently&quot; prefer 4a. This means: the set of XML elements/expression  is in general open, but limited per extension point by the plug-in defining the extension point. </p>
<h4>Standard XML expression language</h4>
<p>An examination of the existing &quot;expression languages&quot;
introduced by the different Eclipse plug-ins shows a common set of used
expression types. This sections defines a basic expression language
which can be extended by plug-ins using the above described mechanism of
expression creator and element handlers.</p>
<p><i><u>Boolean operators</u></i></p><p>The expression language
provides standard expressions for the Boolean operators and, or and not.</p>
<p><u><i>Test expression</i></u></p>
<p>One of the most used expression in current XML files is the one to
test a certain property of an object, including instance of checks. They
are either represented by a XML element (for example the XML element
objectState of systemProperty) or by a special attribute (for example
the objectClass attribute of the object contribution extension point).
The new expression language defines the XML element test to support
property testing. The test element looks like follows:</p>
<blockquote>
<p><code>&lt;test property=&quot;instanceof&quot;
value=&quot;org.eclipse.jdt.core.IJavaElement&quot;/&gt;</code></p>
</blockquote>
<p>This expression tests, if the object in focus (I will explain later
what the object in focus means) is of instance
&quot;org.eclipse.jdt.core.IJavaElement&quot;. Besides a couple of
predefined properties like &quot;instanceof&quot; the set of properties
to test must be open. To avoid the drawbacks associated with
IActionFilters listed above a new mechanism got implemented. The major
characteristics of this mechanism are:</p>
<ul>
	<li>new properties are implemented by a extender which gets contributed
	to a specific type</li>
	<li>the extender and its methods are defined in XML. This is necessary
	to know if a extender provides a certain property test method but the
	property can't be evaluated due to the fact that the plug-in isn't
	loaded yet.</li>
	<li>testing for an unknown property results in a core exception since it
is a programming error.</li>
</ul>
<p>Adding new properties to an existing type is done in XML in the
following way:</p>
<blockquote><pre>&lt;extension point=&quot;org.eclipse.jdt.typeExtenders&quot;&gt;
    &lt;typeExtender
        id=&quot;org.eclipse.jdt.ui.IResourceTypeExtender&quot;
        type=&quot;org.eclipse.core.resources.IResource&quot;
        methods=&quot;matchesPattern, projectNature, canDelete&quot;
        class=&quot;org.eclipse.jdt.internal.corext.refactoring.participants.xml.ResourceTypeExtender&quot;/&gt;
&lt;/extension&gt;</pre></blockquote>
<p>The attributes do have the following meaning:</p>
<ul>
	<li>id: a unique id</li>
	<li>type: the type which gets &quot;enriched&quot; with new properties</li>
	<li>methods: the list of methods provided by the extender. Enumerating
	the properties in XML ensure that a extender only gets loaded iff it
	can handle the property.</li>
	<li>class: the implementing class</li>
</ul>

<p>The implementation of a type extender is comparable to the
implementation of a IActionFilter, except that more than one argument
can be passed and that the signature is Object and not String based. For
concrete implementation have a look at subclasses of TypeExtender.</p>
<p>An XML expression using one of the new properties might look like:</p>

<blockquote>
<pre>
&lt;and&gt;
  &lt;test property=&quot;instanceof&quot; value=&quot;org.eclipse.core.resources.IResource&quot;/&gt;
  &lt;test property=&quot;canDelete&quot;/&gt;
&lt;/and&gt;</pre>
</blockquote>
<p>The implementation of the type extender mechanism contains the additional classes TypeExtension which acts as a facade and the private classes ITypeExtender, TypeExtenderDescriptor, Method and LRUCache. This classes are responsible to lazily create a hierarchy of type extenders and to cache the least-recently used properties.</p>
<p>TBD: Some words about the focus element and properties that require more than one arguments.</p>
<p><u><i>Adapt expression</i></u></p>
<p>As noted in the motivation section it isn't sufficient to support IResource adaption only. To solve this porblem, an XML element of the form:</p>
<blockquote><pre>&lt;adapt type=&quot;org.eclipse.jdt.core.IType&quot;&gt;
  &lt;test property=&quot;hasMainMethod&quot;/&gt;
&lt;/adapt&gt;</pre></blockquote>
<p>is provided. This changes the element in focus to the one that is adapted to the specified type. All child expressions of the adapt expression will then use the adapted object. If the element can't be adapted to the given type, the expression evaluates to false.</p>
<p>The key passed to IAdaptable.getAdapter must be an object of type <code>Class</code>,
not a string. Therefore the class name provided by the XML element must be converted into a <code>Class</code>
object, which can lead to plug-in class loading. The class loader of the
plug-in containing the &lt;adapt type=&quot;...&quot;&gt;
element is used to convert the class name into a <code>Class</code>.
Therefore only required plug-ins might be loaded by this mechanism (no
upcalls). Additionally, availability checks take place on user actions,
hence no unnecessary plug-in loading takes place on start-up.</p>
<p><u><i>Dealing with collection of elements</i></u></p>
<p>Lots of expressions are typically evaluated on a set of elements (for example refactoring participants, menu contributions, ..). Up to now the iteration over sets is implicitly coded in the enclosing XML element, which isn't part of the expression itself. The new mechanism provides explicit expression elements to deal with collection of elements. The following element</p>
<blockquote><pre>&lt;count value=&quot;*&quot;/&gt;</pre></blockquote>
<p>is used to check the number of elements in a collection and is comparable to the enablesFor attribute used for object contributions. To iterate over collections an element</p>
<blockquote><pre>&lt;iterate operator=&quot;and | or&quot;&gt;</pre></blockquote>
<p>is provided. The operator attribute determines how the child results are combined. Using these expression the enablement of a typical menu contribution can be described as follows:</p>
<blockquote><pre>&lt;enablement&gt;
  &lt;count value=&quot;*&quot;/&gt;
  &lt;iterate operator=&quot;and&quot;/&gt;
    &lt;adapt type=&quot;org.eclipse.core.resources.IFile&quot;&gt;
       &lt;test property=&quot;matchesName&quot; value=&quot;*.gif&quot;/&gt;
       &lt;test property=&quot;canDelete&quot;/&gt;
    &lt;/adapt&gt;
  &lt;/iterate&gt;
&lt;/enablement&gt;</pre></blockquote>
<p>Since XML is typically verbose we could provide an additional adapt attribute for the iterate element to avoid to many nested XML elements.</p>

<h3>How to convert existing extension points</h3>
<p>TBD. Mainly discuss how to convert IActionFilter implementations and how to provide system and plug-in properties. May be we should add them to the standard implementation as well.</p>
<h3>The new Home</h3>
<p>The last remaining question is, where to put this new mechanism.
Given the requirement that core and UI plug-ins want to use XML
expressions I see two possible solutions:</p>
<ol>
	<li>both the conversion component and the standard XML expression
	languages is hosted by org.eclipse.core.runtime. A proposal for the new
	package name is org.eclipse.core.expressions</li>
	<li type="1">only the conversion mechanism is hosted by
	org.eclipse.core.runtime. This is necessary to avoid doubling the
	structure in memory as outlines in section &quot;Converting XML
	elements into expressions&quot;. The standard XML expression language
	can be located in a separate plug-in org.eclipse.core.expressions.</li>
</ol><p>I opt for solution 2.</p>
</body>
</html>
